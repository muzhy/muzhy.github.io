---
layout: post
title:  "从零开始的Socket编程 四"
date:   2023-04-09 +0800
categories: Socket C++
---

# 从零开始的Socket编程 四
之前已经给出了简单的非阻塞的socket服务器的代码，也说明了其存在的两个重大缺陷
这次就解决其中的一个缺陷——占用CPU过高的问题

占用CPU过高是由于程序需要不断的检查socket有新连接到达，是否有可读的数据到达导致的。想要降低cpu占用很自然的一个想法就是不要一直去查，而是等待有数据到达的时候才去处理。这时候不就又回到了一开始的阻塞的情况了吗？
所以我们不能让程序自己去阻塞等待到有数据的时候去处理，应该让系统帮我们做这件事。Linux提供了select/poll/ePoll机制来做这件事。

当然，我们也可以考虑利用多线程来完成这件事——socket设置为阻塞的，主线程在accept阻塞等到有新得连接到达，每到达一个新的连接就创建一个新的子线程来处理，子线程在read/write阻塞，这样也可以同时处理多个请求，也不会一直占用cpu资源。存在的问题是每个连接到达时都需要新建线程来处理。

先介绍select/poll/epoll，然后使用这些机制分别实现简单的socket服务器；之后利用多线程的机制实现socket服务器。最后分别说明两种方式的优缺点。后续优化可以考虑使用线程池优化多线程机制下的

## Select, Poll 和 EPoll


## 利用Select/Poll/EPoll

## 将每个请求分配给不同的线程进行处理

## Reactor模式