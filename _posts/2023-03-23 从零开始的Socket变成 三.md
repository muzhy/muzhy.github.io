---
layout: post
title:  "从零开始的Socket编程 三"
date:   2023-03-23 +0800
categories: Socket C++
---

# 从零开始的Socket编程 三
之前已经给出了简单的Socket服务端的简单代码了，但是存在着很多问题。一个最明显的问题就是，该服务一次只能处理一个请求，当有一个请求正在处理时，新到达的请求必须等待，直到现有的请求处理完成后才能被处理。

对于服务端而言，一个明显的要求就是要能处理多个客户端发起的请求，因此第一个改进就是要让程序能够同时处理多个请求。


## 将socket设置为非阻塞
之前的代码之所以必须等待第一个连接处理完成后才能接收新的连接的原因是因为程序在等待数据
```C++
recv(conn, buf, sizeof(buf), 0);
```
时阻塞，且一直等到客户端发送`quit`指令或断开连接后才会开始处理新的连接。
在没有数据到来之前，程序也会一直等待。

很自然的，我们希望当客户端没有新的数据到来时，不要在`recv`阻塞，而是去看看有没有新的连接到来，如果有新的连接到来就处理新的连接。或者看看当前接收的连接中，有没有某些连接已经准备好数据可以读取并进行处理的，处理那些已经准备好的连接。
这就是socket中的非阻塞模式

对socket而言，在阻塞和非阻塞模式下，以下函数具有不同的行为表现：
1. connect
2. accept
3. read(Linux下包括recv)
4. write(Linux下包括send)

socket在创建的时候可以指定为阻塞的(blocking)或非阻塞的(no-blocking)，默认创建的socket都是阻塞的。
所谓阻塞，就当某个函数“执行成功的条件”当前不能满足时，该函数会阻塞当前执行线程，程序执行流在超时时间到达或“执行成功的条件”满足后恢复继续执行。
非阻塞则相反，即使某个函数的“执行成功的条件”不当前不能满足，该函数也不会阻塞当前执行线程，而是立即返回，继续运行执行程序流

```C++
socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, IPPROTO_TCP);
```
创建socket时，type参数增加`SOCK_NONBLOCK`标志即可将socket设置为非阻塞模式，也有其他方式可以进行设置，读者感兴趣的话可自行查找。
将socket设置为非阻塞后，`accept`, `read`, `recv`, `write`, `send`的行为发生变化，相关的代码也需要进行调整。



## 利用Select/Poll/EPOll

## 将每个请求分配给不同的线程进行处理

## Reactor模式

