## 使用Socket
如上文所述，Socket用于在网络上连接两个不同的进程，将这个两个经常分别称为Server和Client，Server就像是插座后面的电源，等待者插头，也就是Client来进行连接。只有当Server和Client成功建立起连接，这时两个进程才可以进行通信。

由于两个进程扮演了不同的角色，需要提供不同的功能，因此Server和Client创建Socket的方式也不同。
![Socket Server和Client通信过程](../image/socket_trans.png)

## Socket 的基本操作
在上文的图中也包括了socket的基本操作，以及这些操作在socket通信过程中所处的位置。
### socket
`int socket (int __domain, int __type, int __protocol)`
该函数创建一个socket描述符（socket descriptor），该描述符唯一标识一个socket，在Linux下该接口的声明为：
```C
/* Create a new socket of type TYPE in domain DOMAIN, using
   protocol PROTOCOL.  If PROTOCOL is zero, one is chosen automatically.
   Returns a file descriptor for the new socket, or -1 for errors.  */
extern int socket (int __domain, int __type, int __protocol) __THROW;
```
#### 参数
1. __domain : 协议域，又称协议族，定义在"sys/socket.h"（Windows系统在winsock2.h）文件中，常用的协议族有：`AF_INET`(IPv4)，`AF_INET6`(IPv6)，`AF_LOCAL`(用于同一台主机上的进程间通信，详细可参考https://blog.csdn.net/frank_jb/article/details/77199834)等。协议族指定了socket的地址类型，在通信中必须采用对应的地址。
2. __type : 指定socket的类型。常用的有`SOCK_STREAM`——面向连接的，常用于TCP，`SOCK_DGRAM`——面向报文的，常用于UDP等。这些类型定义在`socket_type.h`文件中
3. __protocol : 指定协议。常用协议有`IPPROTO_TCP`——TCP协议, `IPPROTO_UDP` ——UDP协议，`IPPROTO_TIPC`——TIPC(Transparent Inter Process Communication)协议

上述type和protocol不可以自由组合，当protocol为0时会根据type选择默认的协议。
#### 返回值
返回新创建的socket描述符，若创建失败则返回-1

### bind
对于server端进程而言，在创建socket后需要将协议族中一个特定的地址赋予socket，在改地址上等待client的连接
```C
/* Give the socket FD the local address ADDR (which is LEN bytes long).  */
extern int bind (int __fd, __CONST_SOCKADDR_ARG __addr, socklen_t __len)
```
1. __fd : 文件描述符，即socket描述符，调用`socket()`的返回值
2. __addr : `#define __CONST_SOCKADDR_ARG	const struct sockaddr *`，指定要绑定的地址，该结构根据创建socket时的地址协议族的不同而不同。如IPv4对应的是
    ```C
    struct sockaddr_in
    {
        __SOCKADDR_COMMON (sin_);
        in_port_t sin_port;			/* Port number.  */
        struct in_addr sin_addr;		/* Internet address.  */

        /* Pad to size of `struct sockaddr'.  */
        unsigned char sin_zero[sizeof (struct sockaddr)
                - __SOCKADDR_COMMON_SIZE
                - sizeof (in_port_t)
                - sizeof (struct in_addr)];
    };
    typedef uint32_t in_addr_t;
    struct in_addr
    {
        in_addr_t s_addr;
    };
    ```
    而IPv6对应的是：
    ```C
    #if !__USE_KERNEL_IPV6_DEFS
    /* Ditto, for IPv6.  */
    struct sockaddr_in6
    {
        __SOCKADDR_COMMON (sin6_);
        in_port_t sin6_port;	/* Transport layer port # */
        uint32_t sin6_flowinfo;	/* IPv6 flow information */
        struct in6_addr sin6_addr;	/* IPv6 address */
        uint32_t sin6_scope_id;	/* IPv6 scope-id */
    };
    #endif /* !__USE_KERNEL_IPV6_DEFS */

    #if !__USE_KERNEL_IPV6_DEFS
    /* IPv6 address */
    struct in6_addr
    {
        union
        {
        uint8_t	__u6_addr8[16];
        uint16_t __u6_addr16[8];
        uint32_t __u6_addr32[4];
        } __in6_u;
    #define s6_addr			__in6_u.__u6_addr8
    #ifdef __USE_MISC
    # define s6_addr16		__in6_u.__u6_addr16
    # define s6_addr32		__in6_u.__u6_addr32
    #endif
    };
    #endif /* !__USE_KERNEL_IPV6_DEFS */
    ```
3. __len ：对应的地址的长度

### listen

## 代码
下面分别是在Server端和Client端使用Socket的代码
### Server
```C++
int main(){
    int listen_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(listen_fd == -1)
    {
        std::cerr << "Error: init socket failed! err[" << errno << "]: " << strerror(errno) << std::endl;
        return furry_toy::NET_SOCKET_INIT_ERR;
    }

    struct sockaddr_in addr;
    // IPv4
    addr.sin_family = AF_INET;
    // 转换为网络字节序
    addr.sin_port = htons(8080);
    // Address to accept any incoming messages. 
    addr.sin_addr.s_addr = INADDR_ANY;

    if(bind(listen_fd, (struct sockaddr*)&addr, sizeof(addr)) == -1)
    {
        std::cerr << "Error: bind socket failed! err[" << errno << "]" << strerror(errno) << std::endl;
        return -1;
    }

    if(listen(listen_fd, 16) == -1)
    {
        std::cerr << "Error: listen failed! err[" << errno << "]" << strerror(errno) << std::endl;
        return -1;
    }

    int conn = 0;
    char client_ip[INET_ADDRSTRLEN] = "";
    struct sockaddr_in client_addr;
    socklen_t client_addr_len = sizeof(client_addr);

    while (true)
    {
        std::cout << "listen..." << std::endl;
        conn = accept(listen_fd, (struct sockaddr*)&client_addr, &client_addr_len);
        if(conn < 0)
        {
            std::cerr << "accept error" << std::endl;
            continue;
        }
        inet_ntop(AF_INET, &client_addr.sin_addr, client_ip, INET_ADDRSTRLEN);
        std::cout << "... connect " << client_ip << ":" << ntohs(client_addr.sin_port) << std::endl;

        char buf[256];
        while (true)
        {
            memset(buf, 0, sizeof(buf));
            int len = recv(conn, buf, sizeof(buf), 0);
            if(len == 0)
            {
                std::cout << "client close connect" << std::endl;
                break;
            }
            else if(len < 0)
            {
                std::cerr << "socket error : " << len << " client_ip " << client_ip << ":" << ntohs(client_addr.sin_port) << std::endl;
                break;
            }
            else
            {
                if(strcmp(buf, "quit\n") == 0 || strcmp(buf, "quit\r\n") == 0)
                {
                    std::cout << "close connect, " << " client_ip " << client_ip << ":" << ntohs(client_addr.sin_port) << std::endl;
                    break;
                }
                else
                {
                    std::cout << buf << std::endl;
                }
            }
        }

        close(conn);        
    }
    
    close(listen_fd);
    return 0;
}
```

### Client