## 使用Socket
如上文所述，Socket用于在网络上连接两个不同的进程，将这个两个经常分别称为Server和Client，Server就像是插座后面的电源，等待者插头，也就是Client来进行连接。只有当Server和Client成功建立起连接，这时两个进程才可以进行通信。

由于两个进程扮演了不同的角色，需要提供不同的功能，因此Server和Client创建Socket的方式也不同。

篇幅所限，本文主要介绍Socket相关的概念性内容，接口相关内容请移步《从零开始的Socket编程 一》

下面分别是在Server端和Client端使用Socket的代码
### Server
```C++
int main(){
    int listen_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(listen_fd == -1)
    {
        std::cerr << "Error: init socket failed! err[" << errno << "]: " << strerror(errno) << std::endl;
        return furry_toy::NET_SOCKET_INIT_ERR;
    }

    struct sockaddr_in addr;
    // IPv4
    addr.sin_family = AF_INET;
    // 转换为网络字节序
    addr.sin_port = htons(8080);
    // Address to accept any incoming messages. 
    addr.sin_addr.s_addr = INADDR_ANY;

    if(bind(listen_fd, (struct sockaddr*)&addr, sizeof(addr)) == -1)
    {
        std::cerr << "Error: bind socket failed! err[" << errno << "]" << strerror(errno) << std::endl;
        return -1;
    }

    if(listen(listen_fd, 16) == -1)
    {
        std::cerr << "Error: listen failed! err[" << errno << "]" << strerror(errno) << std::endl;
        return -1;
    }

    int conn = 0;
    char client_ip[INET_ADDRSTRLEN] = "";
    struct sockaddr_in client_addr;
    socklen_t client_addr_len = sizeof(client_addr);

    while (true)
    {
        std::cout << "listen..." << std::endl;
        conn = accept(listen_fd, (struct sockaddr*)&client_addr, &client_addr_len);
        if(conn < 0)
        {
            std::cerr << "accept error" << std::endl;
            continue;
        }
        inet_ntop(AF_INET, &client_addr.sin_addr, client_ip, INET_ADDRSTRLEN);
        std::cout << "... connect " << client_ip << ":" << ntohs(client_addr.sin_port) << std::endl;

        char buf[256];
        while (true)
        {
            memset(buf, 0, sizeof(buf));
            int len = recv(conn, buf, sizeof(buf), 0);
            if(len == 0)
            {
                std::cout << "client close connect" << std::endl;
                break;
            }
            else if(len < 0)
            {
                std::cerr << "socket error : " << len << " client_ip " << client_ip << ":" << ntohs(client_addr.sin_port) << std::endl;
                break;
            }
            else
            {
                if(strcmp(buf, "quit\n") == 0 || strcmp(buf, "quit\r\n") == 0)
                {
                    std::cout << "close connect, " << " client_ip " << client_ip << ":" << ntohs(client_addr.sin_port) << std::endl;
                    break;
                }
                else
                {
                    std::cout << buf << std::endl;
                }
            }
        }

        close(conn);        
    }
    
    close(listen_fd);
    return 0;
}
```

### Client