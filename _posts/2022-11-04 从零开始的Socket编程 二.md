---
layout: post
title:  "从零开始的Socket编程 二"
date:   2022-11-04 +0800
categories: Socket C++
---

# 从零开始的Socket编程 二

前文已经介绍了socket的相关概念,通信流程和相关接口,本文给出用于socket进行通信的简单代码.虽然代码比较简单,仅能实现通信,无法用于实际的生产环境中,后续将慢慢基于此代码进行改造. 

需要说明的时,代码是基于Linux的,Windows下的Socket需要进行一定的调整

本文的代码在以下系统版本可正常运行
> Linux version 5.10.102.1-microsoft-standard-WSL2 (oe-user@oe-host) (x86_64-msft-linux-gcc (GCC) 9.3.0, GNU ld (GNU Binutils) 2.34.0.20200220) 


## Server
```C++
int main(){
    /* 创建了一个使用TCP协议的socket, 由于TCP是面向连接的,所以socket类型
       为SOCK_STREAM, 若要使用UDP则需要使用SOCK_DGRAM. 
       AF_INET指定地址是IPv4的地址,IPv6需要改为AF_INET6  */
    int listen_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(listen_fd == -1)
    {
        std::cerr << "Error: init socket failed! err[" << errno << "]: " << strerror(errno) << std::endl;
        return -1;
    }
    // addr用来指定要监听的具体地址
    struct sockaddr_in addr;
    // IPv4, 创建socket时已经指定为AF_INET, 这里的应该保持一直
    addr.sin_family = AF_INET;
    // TCP/IP的地址有IP:port组合确定,需要指定监听哪个端口
    // 使用htons将主机字节序转换为网络字节序, 主机字节序和网络字节序不同,永远都不要假设两者相同
    addr.sin_port = htons(8080);
    // Address to accept any incoming messages. 
    addr.sin_addr.s_addr = INADDR_ANY;
    // 设置好要监听的地址参数后, 调用bind绑定到socket上
    if(bind(listen_fd, (struct sockaddr*)&addr, sizeof(addr)) == -1)
    {
        std::cerr << "Error: bind socket failed! err[" << errno << "]" << strerror(errno) << std::endl;
        return -1;
    }
    // 确定要要监听的地址后,就可以其中监听
    if(listen(listen_fd, 16) == -1)
    {
        std::cerr << "Error: listen failed! err[" << errno << "]" << strerror(errno) << std::endl;
        return -1;
    }

    int conn = 0;
    char client_ip[INET_ADDRSTRLEN] = "";
    struct sockaddr_in client_addr;
    socklen_t client_addr_len = sizeof(client_addr);
    
    while (true)
    {
        std::cout << "listen..." << std::endl;
        // 由于没有将socket设置为非阻塞,因此accept会阻塞直到有一个连接到来
        conn = accept(listen_fd, (struct sockaddr*)&client_addr, &client_addr_len);
        // conn是新的连接到来时,有系统为该连接自动创建的socket所对应的描述符
        if(conn < 0)
        {
            std::cerr << "accept error" << std::endl;
            continue;
        }
        // 类似的,需要将网络字节序转换为主机字节序
        inet_ntop(AF_INET, &client_addr.sin_addr, client_ip, INET_ADDRSTRLEN);
        std::cout << "... connect " << client_ip << ":" << ntohs(client_addr.sin_port) << std::endl;

        char buf[256];
        // 在建立起新的连接后,开始进行通信,直到客户端主动断开连接或者处理完成有服务端断开连接
        while (true)
        {
            memset(buf, 0, sizeof(buf));
            // 简单期间,使用recv读取数据
            int len = recv(conn, buf, sizeof(buf), 0);
            // 正常情况下,recv会阻塞直到有收到client发来的数据才会返回,否则意味这通信出现了问题
            if(len == 0)
            {
                std::cout << "client close connect" << std::endl;
                break;
            }
            else if(len < 0)
            {
                std::cerr << "socket error : " << len << " client_ip " << client_ip << ":" << ntohs(client_addr.sin_port) << std::endl;
                break;
            }
            else
            {
                // 处理读取到的数据, 这里假设了收到的包每次都是一行的数据才能这样处理, 
                // 在实际环境下，不应假设每个包都包含了完整的一行数据，需要设置缓冲区读取
                if(strcmp(buf, "quit") == 0 || strcmp(buf, "quit\n") == 0 || strcmp(buf, "quit\r\n") == 0)
                {
                    std::cout << "close connect, " << " client_ip " << client_ip << ":" << ntohs(client_addr.sin_port) << std::endl;
                    break;
                }
                else
                {
                    std::cout << buf << std::endl;
                }
            }
        }

        close(conn);        
    }
    
    close(listen_fd);

    return 0;
}
```
上面给出了简单但却能运行的server端代码, 虽然无法在实际环境下使用,不过用来说明流程也足够了.

执行上面的代码, 在该机上的再运行`telnet 127.0.0.1 8080`即可连接到对应的服务端,可通过设置断点观察程序是如何执行的.
该程序的功能是将在接收到"quit"时退出, 否则将打印接收到的内容.

使用telent进行连接所输出的内容
```
telnet 127.0.0.1 8080
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
helo
my
friend
quit
Connection closed by foreign host.
```
server输出的内容
```
listen...
... connect 127.0.0.1:47242
helo

my

friend

close connect,  client_ip 127.0.0.1:47242
listen...
```

## Client
在有了server端程序后,需要client发起连接才能构成通信. 上文使用了`telnet`作为client发起连接,测试server是否正常运行,
本节将使用代码实现client端的功能.

```C++
#include <iostream>
#include <errno.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <arpa/inet.h>
#include <stdio.h>

int main(int , char **)
{
    int client_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    struct sockaddr_in addr;
    // IPv4
    addr.sin_family = AF_INET;
    addr.sin_port = htons(8080);
    addr.sin_addr.s_addr = inet_addr("127.0.0.1");

    if(connect(client_socket, (struct sockaddr*)&addr, sizeof(addr)) != 0)
    {
        std::cerr << "connet server failed!" << std::endl;
        return -1;
    }

    std::string str;
    while(true)
    {
        std::cin >> str;

        int len = send(client_socket, str.c_str(), str.size(), 0);
        std::cout << "send len " << len << std::endl;
        if(str == "quit")
        {
            break;
        }
    }

    close(client_socket);

    return 0;
}
```

`client`的功能很简单，接收输入的信息然后发送到服务端，当接收到'quit'的时候，服务端会断开连接此时client主动退出循环