---
layout: post
title:  "从零开始的Socket编程 零"
date:   2022-10-31 +0800
categories: Socket C++
---

# 从零开始的Socket编程 零
---

## 引言

## 本文结构
先介绍Socket的概念，了解Socket是什么以及Socket被设计出来是为了做什么的；然后介绍Socket的原理，主要是简单的介绍相关的计算机网络的相关内容。

## Socket是什么
Socket的中文翻译的套接字，但是说实话，一开始看到套接字这三个字完全不知道是什么意思，查询的结果也之后专业的名词解释，无法得到直观的理解，因此本人是不太喜欢套接字这个翻译的。

相对而言，Socket的英文解释就要好得多，毕竟是外来词汇。查到的科林斯的解释如下：
> A socket is a device on a piece of electrical equipment into which you can put a bulb or plug.

看起来就比较直观了，Socket的原意是一种可以将灯泡或插头插入其中的电子设备，也就是插座了。

抽象一点来看，插座用于连接电源和设备，电源提供能量，设备接收能量后执行操作。对应到计算机中也是类似，连接两个设备（进程），一端提供信息（server）另一端接收信息并为执行操作（client）。所以直观来看，Socket在计算机中就是用来连接两个进程的工具。

维基上对Socket给出了更明确的定义：
> A network socket is a software structure within a network node of a computer network that serves as an endpoint for sending and receiving data across the network. The structure and properties of a socket are defined by an application programming interface for the networking architecture.

按照维基上的说法，这里讨论的Socket全称应该是network socket，只是习惯上直接叫socket了。个人认为上文的比喻与维基的解释是差不多了。


## Socket 原理

## 使用Socket
如上文所述，Socket用于在网络上连接两个不同的进程，将这个两个经常分别称为Server和Client，Server就像是插座后面的电源，等待者插头，也就是Client来进行连接。只有当Server和Client成功建立起连接，这时两个进程才可以进行通信。

由于两个进程扮演了不同的角色，需要提供不同的功能，因此Server和Client创建Socket的方式也不同。

篇幅所限，本文主要介绍Socket相关的概念性内容，接口相关内容请移步《从零开始的Socket编程 一》

下面分别是在Server端和Client端使用Socket的代码
### Server
```C++
int main(){
    int listen_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(listen_fd == -1)
    {
        std::cerr << "Error: init socket failed! err[" << errno << "]: " << strerror(errno) << std::endl;
        return furry_toy::NET_SOCKET_INIT_ERR;
    }

    struct sockaddr_in addr;
    // IPv4
    addr.sin_family = AF_INET;
    // 转换为网络字节序
    addr.sin_port = htons(8080);
    // Address to accept any incoming messages. 
    addr.sin_addr.s_addr = INADDR_ANY;

    if(bind(listen_fd, (struct sockaddr*)&addr, sizeof(addr)) == -1)
    {
        std::cerr << "Error: bind socket failed! err[" << errno << "]" << strerror(errno) << std::endl;
        return -1;
    }

    if(listen(listen_fd, 16) == -1)
    {
        std::cerr << "Error: listen failed! err[" << errno << "]" << strerror(errno) << std::endl;
        return -1;
    }

    int conn = 0;
    char client_ip[INET_ADDRSTRLEN] = "";
    struct sockaddr_in client_addr;
    socklen_t client_addr_len = sizeof(client_addr);

    while (true)
    {
        std::cout << "listen..." << std::endl;
        conn = accept(listen_fd, (struct sockaddr*)&client_addr, &client_addr_len);
        if(conn < 0)
        {
            std::cerr << "accept error" << std::endl;
            continue;
        }
        inet_ntop(AF_INET, &client_addr.sin_addr, client_ip, INET_ADDRSTRLEN);
        std::cout << "... connect " << client_ip << ":" << ntohs(client_addr.sin_port) << std::endl;

        char buf[256];
        while (true)
        {
            memset(buf, 0, sizeof(buf));
            int len = recv(conn, buf, sizeof(buf), 0);
            if(len == 0)
            {
                std::cout << "client close connect" << std::endl;
                break;
            }
            else if(len < 0)
            {
                std::cerr << "socket error : " << len << " client_ip " << client_ip << ":" << ntohs(client_addr.sin_port) << std::endl;
                break;
            }
            else
            {
                if(strcmp(buf, "quit\n") == 0 || strcmp(buf, "quit\r\n") == 0)
                {
                    std::cout << "close connect, " << " client_ip " << client_ip << ":" << ntohs(client_addr.sin_port) << std::endl;
                    break;
                }
                else
                {
                    std::cout << buf << std::endl;
                }
            }
        }

        close(conn);        
    }
    
    close(listen_fd);
    return 0;
}
```

### Client