---
layout: post
title:  "从零开始的Socket编程 三"
date:   2023-03-23 +0800
categories: Socket C++
---

# 从零开始的Socket编程 三
之前已经给出了简单的Socket服务端的简单代码了，但是存在着很多问题。一个最明显的问题就是，该服务一次只能处理一个请求，当有一个请求正在处理时，新到达的请求必须等待，直到现有的请求处理完成后才能被处理。

对于服务端而言，一个明显的要求就是要能处理多个客户端发起的请求，因此第一个改进就是要让程序能够同时处理多个请求。


## 将socket设置为非阻塞
之前的代码之所以必须等待第一个连接处理完成后才能接收新的连接的原因是因为程序在等待数据
```C++
recv(conn, buf, sizeof(buf), 0);
```
时阻塞，且一直等到客户端发送`quit`指令或断开连接后才会开始处理新的连接。
在没有数据到来之前，程序也会一直等待。

很自然的，我们希望当客户端没有新的数据到来时，不要在`recv`阻塞，而是去看看有没有新的连接到来，如果有新的连接到来就处理新的连接。或者看看当前接收的连接中，有没有某些连接已经准备好数据可以读取并进行处理的，处理那些已经准备好的连接。
这就是socket中的非阻塞模式

对socket而言，在阻塞和非阻塞模式下，以下函数具有不同的行为表现：
1. connect
2. accept
3. read(Linux下包括recv)
4. write(Linux下包括send)

socket在创建的时候可以指定为阻塞的(blocking)或非阻塞的(no-blocking)，默认创建的socket都是阻塞的。
所谓阻塞，就当某个函数“执行成功的条件”当前不能满足时，该函数会阻塞当前执行线程，程序执行流在超时时间到达或“执行成功的条件”满足后恢复继续执行。
非阻塞则相反，即使某个函数的“执行成功的条件”不当前不能满足，该函数也不会阻塞当前执行线程，而是立即返回，继续运行执行程序流

```C++
socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, IPPROTO_TCP);
```
创建socket时，type参数增加`SOCK_NONBLOCK`标志即可将socket设置为非阻塞模式，也有其他方式可以进行设置，读者感兴趣的话可自行查找。
将socket设置为非阻塞后，`accept`, `read`, `recv`, `write`, `send`的行为发生变化，相关的代码也需要进行调整。

之前已经有创建阻塞的socket的代码了，创建非阻塞的代码与之类似，将创建并监听socket的代码封装为一个函数，是否是阻塞的socket通过参数传递：
```C++
SOCKET_TYPE createAndListenTcpSocket(int port, int max_wait_socket, int type)
{
    /************************************************************************
     * int  socket(int protofamily, int type, int protocol);    //返回sockfd
     * @param protofamily 协议域，常用的协议域有：AF_INET(IPV4)、AF_INET6(IPV6)、
     *  AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE... 
     *  协议域定义了socket的地址类型，在通信中必须采用对应的地址，在socket.h中定义
     * @param type socket类型，常用类型：SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、
     *  SOCK_PACKET、SOCK_SEQPACKET... 在socket_type.h中定义
     * @param protocol 协议，IPPROTO_TCP、IPPTOTO_UDP、
     *  IPPROTO_SCTP、IPPROTO_TIPC， 为0时自动选择type类型对应的默认协议
     * type 和protocol不能随意组合
     * @return sockfd socket描述符
     * 以下代码创建了一个TCP连接的sockfd
    *************************************************************************/
    int listen_fd = socket(AF_INET, type, IPPROTO_TCP);
    if(listen_fd == -1)
    {
        std::cerr << "Error: init socket failed! err[" << errno << "]: " << strerror(errno) << std::endl;
        return -1;
    }

    struct sockaddr_in addr;
    // IPv4
    addr.sin_family = AF_INET;
    // 转换为网络字节序
    addr.sin_port = htons(port);
    // Address to accept any incoming messages. 
    addr.sin_addr.s_addr = INADDR_ANY;

    if(bind(listen_fd, (struct sockaddr*)&addr, sizeof(addr)) == -1)
    {
        std::cerr << "Error: bind socket failed! err[" << errno << "]" << strerror(errno) << std::endl;
        return -1;
    }

    if(listen(listen_fd, max_wait_socket) == -1)
    {
        std::cerr << "Error: listen failed! err[" << errno << "]" << strerror(errno) << std::endl;
        return -1;
    }

    return listen_fd;
}
```

## 以非阻塞的方式处理连接
现在有了一个非阻塞的socket了，此时调用`accept`后，程序不会阻塞直到有新的连接到来，当没有新连接时，返回-1，
因此调用`accept`的处理方式要有所不同：
```C++
    while(true)
    {
        conn = accept(listen_fd, (struct sockaddr*)&client_addr, &client_addr_len);
        if(conn != -1)
        {
            inet_ntop(AF_INET, &client_addr.sin_addr, client_ip, INET_ADDRSTRLEN);
            std::cout << "... connect " << client_ip << ":" << ntohs(client_addr.sin_port) << std::endl;
            conn_set.insert(conn);
        }
    }
```
当accept返回-1时说明没有连接到达，当有连接到达时，我们需要把连接记录下来，以便后续处理该连接的请求。

类似的，读取数据时也需要不同的处理方式：
```C++
std::vector<int> close_conn_vec;
 
for(auto connect : conn_set)
{
    memset(buf, 0, sizeof(buf));
    int len = recv(connect, buf, sizeof(buf), MSG_DONTWAIT);
    if(len > 0)
    {
        if(strcmp(buf, "quit") == 0 || strcmp(buf, "quit\n") == 0 || strcmp(buf, "quit\r\n") == 0)
        {
           close_conn_vec.push_back(connect);
        }
        else
        {
            std::cout << buf << std::endl;
        }
    }
    else if(len == 0)
    {
        close_conn_vec.push_back(connect);
    }
}
```
这里创建了一个记录需要关闭连接的`vector` —— `close_conn_vec`，读取数据后的处理方式与之前的代码一样
我们的代码并不需要记录数据，若在需要记录数据等待到某一时刻（如读取到一行再进行处理）的情况，需要为每个连接创建不同的缓冲区记录数据，此处不做展开

需要注意的是，`recv`的flag在这里被设置为`MSG_DONTWAIT`，之前的代码时设置为0，`MSG_DONTWAIT`告诉`recv`启用非阻塞模式，如果操作会阻塞，函数返回-1，并设置errno为EAGAIN或EWOULDBLOCK、

如果不设置此flag，程序将在recv出阻塞等待输入。

## 完整的代码
```C++
SOCKET_TYPE createAndListenTcpSocket(int port, int max_wait_socket, int type)
{
    /************************************************************************
     * int  socket(int protofamily, int type, int protocol);    //返回sockfd
     * @param protofamily 协议域，常用的协议域有：AF_INET(IPV4)、AF_INET6(IPV6)、
     *  AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE... 
     *  协议域定义了socket的地址类型，在通信中必须采用对应的地址，在socket.h中定义
     * @param type socket类型，常用类型：SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、
     *  SOCK_PACKET、SOCK_SEQPACKET... 在socket_type.h中定义
     * @param protocol 协议，IPPROTO_TCP、IPPTOTO_UDP、
     *  IPPROTO_SCTP、IPPROTO_TIPC， 为0时自动选择type类型对应的默认协议
     * type 和protocol不能随意组合
     * @return sockfd socket描述符
     * 以下代码创建了一个TCP连接的sockfd
    *************************************************************************/
    int listen_fd = socket(AF_INET, type, IPPROTO_TCP);
    if(listen_fd == -1)
    {
        std::cerr << "Error: init socket failed! err[" << errno << "]: " << strerror(errno) << std::endl;
        return -1;
    }

    struct sockaddr_in addr;
    // IPv4
    addr.sin_family = AF_INET;
    // 转换为网络字节序
    addr.sin_port = htons(port);
    // Address to accept any incoming messages. 
    addr.sin_addr.s_addr = INADDR_ANY;

    if(bind(listen_fd, (struct sockaddr*)&addr, sizeof(addr)) == -1)
    {
        std::cerr << "Error: bind socket failed! err[" << errno << "]" << strerror(errno) << std::endl;
        return -1;
    }

    if(listen(listen_fd, max_wait_socket) == -1)
    {
        std::cerr << "Error: listen failed! err[" << errno << "]" << strerror(errno) << std::endl;
        return -1;
    }

    return listen_fd;
}

int startNoblockingTcpServer(int port, int max_wait_socket, std::string& err)
{
    // 创建非阻塞的Socket
    int listen_fd = createAndListenTcpSocket(port, max_wait_socket, SOCK_STREAM | SOCK_NONBLOCK);
    if(listen_fd == -1)
    {
        return furry_toy::NET_SOCKET_INIT_ERR;
    }

    int conn = 0;
    char client_ip[INET_ADDRSTRLEN] = "";
    struct sockaddr_in client_addr;
    socklen_t client_addr_len = sizeof(client_addr);
    std::set<int> conn_set;
    char buf[256];

    while(true)
    {
        conn = accept(listen_fd, (struct sockaddr*)&client_addr, &client_addr_len);
        if(conn != -1)
        {
            inet_ntop(AF_INET, &client_addr.sin_addr, client_ip, INET_ADDRSTRLEN);
            std::cout << "... connect " << client_ip << ":" << ntohs(client_addr.sin_port) << std::endl;
            conn_set.insert(conn);
        }
        std::vector<int> close_conn_vec;
        
        for(auto connect : conn_set)
        {
            memset(buf, 0, sizeof(buf));
            int len = recv(connect, buf, sizeof(buf), MSG_DONTWAIT);
            if(len > 0)
            {
                if(strcmp(buf, "quit") == 0 || strcmp(buf, "quit\n") == 0 || strcmp(buf, "quit\r\n") == 0)
                {
                   close_conn_vec.push_back(connect);
                }
                else
                {
                    std::cout << buf << std::endl;
                }
            }
            else if(len == 0)
            {
                close_conn_vec.push_back(connect);
            }
        }

        for(auto connect : close_conn_vec)
        {
            conn_set.erase(connect);
            shutdown(connect, SHUT_RDWR);
            close(connect); 
        }
    }

    close(listen_fd);

    return 0;
}

int main(int, char**) {
    std::string err;
    startNoblockingTcpServer(8080, 10, err);
    return 0;
}
```
与之前的代码相比，我们将创建socket的流程封装为一个函数，同时启动服务监听端口并处理数据也封装为函数，方便调用
现在运行上面的代码，将启动一个监听8080端口的服务器，并能同时处理多个请求

## 缺陷
现在程序虽然能同时处理多个请求了，但是还是存在着非常大的缺陷：
1. 程序需要不断的检查有没有新的连接到，有没有新的数据到，将占用大量的cpu资源，如果在linux上使用top查看资源占用，可以看到程序的CPU占用一直在100%。即使没有连接的情况下也是如此
2. 程序接收数据后立即处理，没有存储连接之前的数据，对于TCP流而言，无法保证一次recv就能读取到所有的数据。按现在的做法，几乎无法处理稍微复杂点的请求。

